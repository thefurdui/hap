#!/usr/bin/env bash
# hap - Hive Agent Pilot
# https://github.com/thefurdui/hap
# License: MIT

set -e

# --- CONFIG ---
APP_NAME="hap"
VERSION="0.5.0"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
DATA_DIR="$XDG_DATA_HOME/$APP_NAME"
DB_FILE="$DATA_DIR/projects.csv"

# PID lock file name (created inside workspaces)
PID_LOCK_FILE=".hap.pid"

# --- COLORS ---
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() { echo -e "${BLUE}INFO:${NC} $1"; }
log_succ() { echo -e "${GREEN}OK:${NC}   $1"; }
log_warn() { echo -e "${YELLOW}WARN:${NC} $1"; }
log_err() { echo -e "${RED}ERR:${NC}  $1" >&2; }

# --- HELPERS ---

zellij_session_exists() {
  local session_name="$1"
  if command -v zellij &>/dev/null; then
    zellij list-sessions 2>/dev/null | grep -q "^${session_name}$" && return 0
  fi
  return 1
}

pid_is_alive() {
  local pid="$1"
  [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null
}

# --- CLEANUP FUNCTIONS ---

cleanup_workspace() {
  local ws_path="$1"
  local sources_dir="$2"
  local delete_local="${3:-false}"
  local delete_remote="${4:-false}"

  [[ ! -d "$ws_path" ]] && return 0

  # Check for uncommitted changes
  for repo in "$ws_path"/*; do
    if [[ -e "$repo/.git" ]]; then
      local status=$(git -C "$repo" status --porcelain 2>/dev/null || echo "")
      if [[ -n "$status" ]]; then
        log_warn "Preserving $(basename "$ws_path") â€” uncommitted changes"
        return 1
      fi
    fi
  done

  # Collect branches to delete if requested
  local branches_to_delete=()
  if [[ "$delete_local" == "true" || "$delete_remote" == "true" ]]; then
    for repo in "$ws_path"/*; do
      if [[ -e "$repo/.git" ]]; then
        local branch=$(git -C "$repo" symbolic-ref --short HEAD 2>/dev/null || echo "")
        if [[ -n "$branch" ]]; then
          branches_to_delete+=("$(basename "$repo")|$branch")
        fi
      fi
    done
  fi

  # Move out of directory to avoid locks
  cd / || true

  # Remove worktrees
  for repo in "$ws_path"/*; do
    if [[ -e "$repo/.git" ]]; then
      local repo_name=$(basename "$repo")
      git -C "$sources_dir/$repo_name" worktree prune 2>/dev/null || true
      git -C "$sources_dir/$repo_name" worktree remove "$repo" --force 2>/dev/null || true
    fi
  done

  # Remove PID lock file first
  rm -f "$ws_path/$PID_LOCK_FILE" 2>/dev/null || true

  # Remove directory (with simple retry)
  local retry=0
  while [[ -d "$ws_path" && $retry -lt 5 ]]; do
    rm -rf "$ws_path" 2>/dev/null || true
    [[ -d "$ws_path" ]] && sleep 0.2 || true
    retry=$((retry + 1))
  done

  if [[ ! -d "$ws_path" ]]; then
    # Delete refs if requested
    for item in "${branches_to_delete[@]}"; do
      local repo_name="${item%|*}"
      local branch="${item#*|}"
      local source_repo="$sources_dir/$repo_name"

      if [[ -d "$source_repo" ]]; then
        if [[ "$delete_remote" == "true" ]]; then
          log_info "Deleting remote branch $branch for $repo_name..."
          git -C "$source_repo" push origin --delete "$branch" 2>/dev/null || true
        fi
        if [[ "$delete_local" == "true" ]]; then
          log_info "Deleting local branch $branch for $repo_name..."
          git -C "$source_repo" branch -D "$branch" 2>/dev/null || true
        fi
      fi
    done
    return 0
  else
    return 1
  fi
}

cleanup_project_workspaces() {
  local project_root="$1"
  local task="$2"
  local sources_dir="$project_root/sources"
  local workspaces_dir="$project_root/workspaces"

  [[ ! -d "$workspaces_dir" ]] && return

  # Confirmation for Remote Delete
  if [[ "$DELETE_REMOTE" == "true" && "$CONFIRM_YES" != "true" ]]; then
    echo -n "WARNING: You are about to delete REMOTE branches. This cannot be undone. Continue? [y/N] "
    read -r response
    if [[ ! "$response" =~ ^[yY]$ ]]; then
      log_warn "Aborted by user."
      return
    fi
  fi

  local delete_local="true"
  local delete_remote="$DELETE_REMOTE"

  if [[ -n "$task" ]]; then
    # TARGETED CLEANUP: TRUST THE USER.
    # No checks for PID/Session. If they typed the name, they want it gone.
    local ws_path="$workspaces_dir/$task"
    log_info "Cleaning workspace: $task"
    if cleanup_workspace "$ws_path" "$sources_dir" "$delete_local" "$delete_remote"; then
      log_succ "Cleaned: $task"
    else
      log_warn "Failed to clean: $task (maybe uncommitted changes?)"
    fi
  else
    # BULK CLEANUP: SAFETY IS PARAMOUNT.
    # We must skip active workspaces.
    log_info "Running bulk cleanup for inactive workspaces..."
    for ws_path in "$workspaces_dir"/*; do
      [[ ! -d "$ws_path" ]] && continue
      local ws_name=$(basename "$ws_path")
      [[ "$ws_name" == "main" ]] && continue

      # CHECK ACTIVITY
      local pid_file="$ws_path/$PID_LOCK_FILE"
      local is_active=0

      if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null || echo "")
        if pid_is_alive "$pid"; then is_active=1; fi
      else
        local session_name="$(basename "$project_root")-$ws_name"
        if zellij_session_exists "$session_name"; then is_active=1; fi
      fi

      if [[ $is_active -eq 1 ]]; then
        log_info "Skipping active workspace: $ws_name"
        continue
      fi

      # It's inactive, safe to clean
      if cleanup_workspace "$ws_path" "$sources_dir" "$delete_local" "$delete_remote"; then
        log_succ "Cleaned: $ws_name"
      fi
    done
  fi
}

# --- SETUP ---

ensure_setup() {
  local editor="${1:-zellij}"
  mkdir -p "$DATA_DIR"
  [[ ! -f "$DB_FILE" ]] && touch "$DB_FILE" || true

  for cmd in fzf git; do
    if ! command -v "$cmd" &>/dev/null; then
      log_err "Missing dependency: $cmd"
      exit 1
    fi
  done

  if ! command -v "$editor" &>/dev/null; then
    log_err "Missing dependency: $editor"
    exit 1
  fi
}

# --- SESSION LAUNCH ---

launch_session() {
  local project_name="$1"
  local workspace_path="$2"
  local session_name="$3"
  local mode="$4"
  local project_root="$5"
  local editor="${6:-zellij}"

  [[ ! -d "$workspace_path" ]] && {
    log_err "Path not found: $workspace_path"
    exit 1
  }

  cd "$workspace_path" || exit 1

  log_info "Launching $project_name ($mode) with $editor..."

  case "$editor" in
  zellij)
    zellij delete-session "$session_name" 2>/dev/null || true

    local layout_file=""
    local project_config_dir="$project_root/config"

    if [[ "$mode" == "lite" ]]; then
      if [[ -f "$project_config_dir/hap-lite.kdl" ]]; then
        layout_file="$project_config_dir/hap-lite.kdl"
      elif [[ -f "$project_config_dir/hap.kdl" ]]; then
        log_warn "hap-lite.kdl missing, falling back to full layout"
        layout_file="$project_config_dir/hap.kdl"
      fi
    else
      if [[ -f "$project_config_dir/hap.kdl" ]]; then
        layout_file="$project_config_dir/hap.kdl"
      elif [[ -f "$project_config_dir/hap-lite.kdl" ]]; then
        log_warn "hap.kdl missing, using lite layout"
        layout_file="$project_config_dir/hap-lite.kdl"
      fi
    fi

    local args=()
    [[ -n "$layout_file" ]] && args+=("--new-session-with-layout" "$layout_file") || true
    args+=("--session" "$session_name")

    unset ZELLIJ ZELLIJ_SESSION_NAME ZELLIJ_PANE_ID
    log_info "Command: zellij ${args[*]}"
    env -u ZELLIJ -u ZELLIJ_SESSION_NAME -u ZELLIJ_PANE_ID zellij "${args[@]}" || true
    ;;
  cursor | antigravity)
    log_info "Command: $editor --new-window --wait ."
    "$editor" --new-window --wait . || true
    ;;
  *)
    log_err "Unsupported editor: $editor"
    exit 1
    ;;
  esac
}

# --- WORKSPACE ---

create_workspace() {
  local project_root="$1"
  local project_name="$2"
  local agent_task="$3"
  local base_branch="$4"
  local editor="${5:-zellij}"
  local target_branch_prefix="$6"

  local sources_dir="$project_root/sources"
  local target_ws="$project_root/workspaces/$agent_task"

  if [[ -d "$target_ws" ]]; then
    log_warn "Resuming existing workspace: $agent_task"
  else
    log_info "Spawning Workspace: $agent_task (Base: $base_branch)"
    mkdir -p "$target_ws"

    for repo in "$sources_dir"/*; do
      if [[ -d "$repo" && -d "$repo/.git" ]]; then
        local repo_name=$(basename "$repo")
        local branch_name=""

        if [[ -n "$target_branch_prefix" ]]; then
          branch_name="${target_branch_prefix}"
        else
          branch_name="hap/${agent_task}"
        fi

        git -C "$repo" worktree prune

        if ! git -C "$repo" worktree add "$target_ws/$repo_name" -b "$branch_name" "$base_branch" 2>/dev/null; then
          git -C "$repo" worktree add "$target_ws/$repo_name" "$branch_name"
        fi

        git -C "$target_ws/$repo_name" push -u origin "$branch_name" 2>/dev/null || true

        # Shared State Linking
        if [[ -d "$project_root/shared/$repo_name" ]]; then
          log_info "Linking shared state for $repo_name..."
          (
            cd "$project_root/shared/$repo_name" || exit
            find . -type f | while read -r file; do
              local clean_file="${file#./}"
              local dest_file="$target_ws/$repo_name/$clean_file"
              local dest_dir=$(dirname "$dest_file")

              mkdir -p "$dest_dir"

              local ups="../../../"
              local subdir=$(dirname "$clean_file")
              if [[ "$subdir" != "." ]]; then
                local sub_depth=$(echo "$subdir" | awk -F/ '{print NF}')
                for ((i = 0; i < sub_depth; i++)); do ups="../$ups"; done
              fi

              ln -sf "${ups}shared/$repo_name/$clean_file" "$dest_file"
            done
          )
        fi

        if [[ -f "$target_ws/$repo_name/pnpm-lock.yaml" ]]; then
          (cd "$target_ws/$repo_name" && pnpm install --frozen-lockfile --silent &)
        elif [[ -f "$target_ws/$repo_name/go.mod" ]]; then
          (cd "$target_ws/$repo_name" && go mod download &)
        fi
      fi
    done
    wait
    log_succ "Workspace ready"
  fi

  # Create PID lock file (Needed for BULK cleanup safety)
  echo "$$" >"$target_ws/$PID_LOCK_FILE"

  local original_dir=$(pwd)
  cd "$target_ws" || exit 1
  launch_session "$project_name" "$target_ws" "$project_name-$agent_task" "lite" "$project_root" "$editor"

  # Remove PID when editor exits (Mark as inactive for Bulk cleanup)
  rm -f "$target_ws/$PID_LOCK_FILE"
  cd "$original_dir" || true
}

# --- CLI ---

usage() {
  cat <<EOF
Usage: $APP_NAME [options]
  -s <name> [path]    Save project
  -w <name> <task>    Start workspace (Lite mode)
  -c <name> [task]    Cleanup workspace(s) (Default: local only)
  -D                  Force delete remote branch (Used with -c)
  -y                  Confirm dangerous actions (Used with -D)
  -m <lite|full>      Force mode
  -e <editor>         Editor: zellij, cursor, antigravity (default: zellij)
  -b <branch>         Base branch for workspace (default: dev)
  -B <branch>         Target branch name (default: hap/<task>)
  -d <name>           Delete project
  -l                  List projects
  -v                  Show version
  (no args)           Open interactive selection
EOF
}

# --- MAIN ---

PROJECT_ARG=""
TASK_ARG=""
BRANCH_ARG="dev"
TARGET_BRANCH_ARG=""
MODE_ARG="default"
EDITOR_ARG="zellij"
ACTION="interactive"
DELETE_REMOTE="false"
CONFIRM_YES="false"

while getopts "s:d:p:w:b:B:m:e:c:Dy:lhv" opt; do
  case $opt in
  s)
    ACTION="save"
    PROJECT_ARG="$OPTARG"
    eval "NEXT_OPT=\${$OPTIND}"
    if [[ -n "$NEXT_OPT" && "$NEXT_OPT" != -* ]]; then
      PROJECT_PATH="$NEXT_OPT"
      OPTIND=$((OPTIND + 1))
    else
      PROJECT_PATH="."
    fi
    ;;
  d)
    ACTION="delete"
    PROJECT_ARG="$OPTARG"
    ;;
  p)
    ACTION="open"
    PROJECT_ARG="$OPTARG"
    ;;
  b) BRANCH_ARG="$OPTARG" ;;
  B) TARGET_BRANCH_ARG="$OPTARG" ;;
  m) MODE_ARG="$OPTARG" ;;
  e) EDITOR_ARG="$OPTARG" ;;
  v)
    echo "hap v$VERSION"
    exit 0
    ;;
  w)
    ACTION="worktree"
    PROJECT_ARG="$OPTARG"
    eval "TASK_ARG=\${$OPTIND}"
    [[ -z "$TASK_ARG" || "$TASK_ARG" == -* ]] && {
      log_err "Missing task name"
      exit 1
    }
    OPTIND=$((OPTIND + 1))
    ;;
  c)
    ACTION="cleanup"
    PROJECT_ARG="$OPTARG"
    eval "TASK_ARG=\${$OPTIND}"
    if [[ -n "$TASK_ARG" && "$TASK_ARG" != -* ]]; then
      OPTIND=$((OPTIND + 1))
    else
      TASK_ARG=""
    fi
    ;;
  D) DELETE_REMOTE="true" ;;
  y) CONFIRM_YES="true" ;;
  l)
    column -t -s "|" "$DB_FILE"
    exit 0
    ;;
  h)
    usage
    exit 0
    ;;
  *)
    usage
    exit 1
    ;;
  esac
done

ensure_setup "$EDITOR_ARG"

case $ACTION in
save)
  [[ "$PROJECT_PATH" == "." ]] && FULL_PATH="$(pwd)" || FULL_PATH="$(cd "$PROJECT_PATH" && pwd)"
  echo "$PROJECT_ARG|$FULL_PATH" >>"$DB_FILE"
  log_succ "Saved $PROJECT_ARG"
  ;;
open)
  PATH_TO_ROOT=$(grep "^$PROJECT_ARG|" "$DB_FILE" | cut -d '|' -f 2 || true)
  if [[ -z "$PATH_TO_ROOT" ]]; then
    log_err "Project not found: $PROJECT_ARG"
    exit 1
  fi
  launch_session "$PROJECT_ARG" "$PATH_TO_ROOT/workspaces/main" "$PROJECT_ARG-main" "$MODE_ARG" "$PATH_TO_ROOT" "$EDITOR_ARG"
  ;;
worktree)
  PATH_TO_ROOT=$(grep "^$PROJECT_ARG|" "$DB_FILE" | cut -d '|' -f 2 || true)
  if [[ -z "$PATH_TO_ROOT" ]]; then
    log_err "Project not found: $PROJECT_ARG"
    exit 1
  fi
  create_workspace "$PATH_TO_ROOT" "$PROJECT_ARG" "$TASK_ARG" "$BRANCH_ARG" "$EDITOR_ARG" "$TARGET_BRANCH_ARG"
  ;;
cleanup)
  PATH_TO_ROOT=$(grep "^$PROJECT_ARG|" "$DB_FILE" | cut -d '|' -f 2 || true)
  if [[ -z "$PATH_TO_ROOT" ]]; then
    log_err "Project not found: $PROJECT_ARG"
    exit 1
  fi
  cleanup_project_workspaces "$PATH_TO_ROOT" "$TASK_ARG"
  ;;
interactive)
  if [[ ! -s "$DB_FILE" ]]; then
    log_warn "No projects found. Use 'hap -s <name> <path>' to save one."
    exit 0
  fi
  SELECTION=$(fzf --height=40% --layout=reverse --border --prompt="Select Hive > " --delimiter="|" --with-nth=1,2 <"$DB_FILE")
  if [[ -n "$SELECTION" ]]; then
    NAME=$(echo "$SELECTION" | cut -d '|' -f 1)
    PATH_TO_ROOT=$(echo "$SELECTION" | cut -d '|' -f 2)
    launch_session "$NAME" "$PATH_TO_ROOT/workspaces/main" "$NAME-main" "$MODE_ARG" "$PATH_TO_ROOT" "$EDITOR_ARG"
  fi
  ;;
esac
