#!/usr/bin/env bash
# hap - Hive Agent Pilot
# https://github.com/thefurdui/hap
# License: MIT

set -e

# --- CONFIG ---
APP_NAME="hap"
VERSION="0.4.0"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
DATA_DIR="$XDG_DATA_HOME/$APP_NAME"
DB_FILE="$DATA_DIR/projects.csv"

# PID lock file name (created inside workspaces)
PID_LOCK_FILE=".hap.pid"

# --- COLORS ---
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() { echo -e "${BLUE}INFO:${NC} $1"; }
log_succ() { echo -e "${GREEN}OK:${NC}   $1"; }
log_warn() { echo -e "${YELLOW}WARN:${NC} $1"; }
log_err() { echo -e "${RED}ERR:${NC}  $1" >&2; }

# --- CLEANUP FUNCTIONS ---

cleanup_workspace() {
  local ws_path="$1"
  local sources_dir="$2"

  [[ ! -d "$ws_path" ]] && return 0

  # Check for uncommitted changes
  for repo in "$ws_path"/*; do
    if [[ -e "$repo/.git" ]]; then
      local status=$(git -C "$repo" status --porcelain 2>/dev/null || echo "")
      if [[ -n "$status" ]]; then
        log_warn "Preserving $(basename "$ws_path") â€” uncommitted changes"
        return 1
      fi
    fi
  done

  # Move out of directory to avoid locks
  cd / || true

  # Remove worktrees
  for repo in "$ws_path"/*; do
    if [[ -e "$repo/.git" ]]; then
      local repo_name=$(basename "$repo")
      git -C "$sources_dir/$repo_name" worktree prune 2>/dev/null || true
      git -C "$sources_dir/$repo_name" worktree remove "$repo" --force 2>/dev/null || true
    fi
  done

  # Remove PID lock file first
  rm -f "$ws_path/$PID_LOCK_FILE" 2>/dev/null || true

  # Remove directory (with simple retry for any lingering handles)
  local retry=0
  while [[ -d "$ws_path" && $retry -lt 5 ]]; do
    rm -rf "$ws_path" 2>/dev/null || true
    [[ -d "$ws_path" ]] && sleep 0.2 || true
    retry=$((retry + 1))
  done

  [[ ! -d "$ws_path" ]] && return 0 || return 1
}

# Check if a Zellij session exists
zellij_session_exists() {
  local session_name="$1"
  if command -v zellij &>/dev/null; then
    zellij list-sessions 2>/dev/null | grep -q "^${session_name}$" && return 0
  fi
  return 1
}

# Check if a PID is alive
pid_is_alive() {
  local pid="$1"
  [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null
}

# Zombie cleanup - self-healing at startup
cleanup_zombies() {
  local project_root="$1"
  local workspaces_dir="$project_root/workspaces"
  local sources_dir="$project_root/sources"

  [[ ! -d "$workspaces_dir" ]] && return

  for ws_path in "$workspaces_dir"/*; do
    [[ ! -d "$ws_path" ]] && continue
    local ws_name=$(basename "$ws_path")

    # Skip main workspace
    [[ "$ws_name" == "main" ]] && continue

    local pid_file="$ws_path/$PID_LOCK_FILE"

    if [[ -f "$pid_file" ]]; then
      # Has PID file - check if process is alive
      local pid=$(cat "$pid_file" 2>/dev/null || echo "")
      if ! pid_is_alive "$pid"; then
        log_info "Cleaning zombie workspace: $ws_name (dead PID: $pid)"
        if cleanup_workspace "$ws_path" "$sources_dir"; then
          log_succ "Cleaned: $ws_name"
        fi
      fi
    else
      # No PID file - legacy or Zellij workspace
      # Check if Zellij session exists
      local session_name="$(basename "$project_root")-$ws_name"
      if ! zellij_session_exists "$session_name"; then
        log_info "Cleaning orphaned workspace: $ws_name (no active session)"
        if cleanup_workspace "$ws_path" "$sources_dir"; then
          log_succ "Cleaned: $ws_name"
        fi
      fi
    fi
  done
}

# Run zombie cleanup for all registered projects
cleanup_all_zombies() {
  [[ ! -f "$DB_FILE" ]] && return

  while IFS='|' read -r name path; do
    [[ -z "$name" || -z "$path" ]] && continue
    [[ -d "$path" ]] && cleanup_zombies "$path"
  done <"$DB_FILE"
}

# --- SETUP ---

ensure_setup() {
  local editor="${1:-zellij}"
  mkdir -p "$DATA_DIR"
  [[ ! -f "$DB_FILE" ]] && touch "$DB_FILE" || true

  # Check dependencies
  for cmd in fzf git; do
    if ! command -v "$cmd" &>/dev/null; then
      log_err "Missing dependency: $cmd"
      exit 1
    fi
  done

  if ! command -v "$editor" &>/dev/null; then
    log_err "Missing dependency: $editor"
    exit 1
  fi

  # Clean up zombies from all projects
  cleanup_all_zombies
}

# --- SESSION LAUNCH ---

launch_session() {
  local project_name="$1"
  local workspace_path="$2"
  local session_name="$3"
  local mode="$4"
  local project_root="$5"
  local editor="${6:-zellij}"

  [[ ! -d "$workspace_path" ]] && {
    log_err "Path not found: $workspace_path"
    exit 1
  }

  cd "$workspace_path" || exit 1

  log_info "Launching $project_name ($mode) with $editor..."

  case "$editor" in
  zellij)
    # Prune Zellij session if it exists
    zellij delete-session "$session_name" 2>/dev/null || true

    local layout_file=""
    local project_config_dir="$project_root/config"

    # Priority: requested mode -> fallback mode -> default
    if [[ "$mode" == "lite" ]]; then
      if [[ -f "$project_config_dir/hap-lite.kdl" ]]; then
        layout_file="$project_config_dir/hap-lite.kdl"
      elif [[ -f "$project_config_dir/hap.kdl" ]]; then
        log_warn "hap-lite.kdl missing, falling back to full layout"
        layout_file="$project_config_dir/hap.kdl"
      fi
    else
      if [[ -f "$project_config_dir/hap.kdl" ]]; then
        layout_file="$project_config_dir/hap.kdl"
      elif [[ -f "$project_config_dir/hap-lite.kdl" ]]; then
        log_warn "hap.kdl missing, using lite layout"
        layout_file="$project_config_dir/hap-lite.kdl"
      fi
    fi

    local args=()
    [[ -n "$layout_file" ]] && args+=("--new-session-with-layout" "$layout_file") || true
    args+=("--session" "$session_name")

    unset ZELLIJ ZELLIJ_SESSION_NAME ZELLIJ_PANE_ID
    log_info "Command: zellij ${args[*]}"

    # Run as subprocess so script survives and cleanup can run
    env -u ZELLIJ -u ZELLIJ_SESSION_NAME -u ZELLIJ_PANE_ID zellij "${args[@]}" || true
    ;;
  cursor | antigravity)
    log_info "Command: $editor --new-window --wait ."
    # Script blocks here until editor window closes
    "$editor" --new-window --wait . || true
    ;;
  *)
    log_err "Unsupported editor: $editor"
    exit 1
    ;;
  esac
}

# --- WORKSPACE ---

# Global variables for cleanup trap
_CLEANUP_WS_PATH=""
_CLEANUP_SOURCES_DIR=""
_CLEANUP_TASK_NAME=""

# Cleanup function for trap - must be idempotent
do_cleanup() {
  # Avoid recursive calls
  trap - EXIT SIGINT SIGTERM SIGHUP

  [[ -z "$_CLEANUP_WS_PATH" ]] && return 0
  [[ ! -d "$_CLEANUP_WS_PATH" ]] && return 0

  log_info "Cleaning up workspace: $_CLEANUP_TASK_NAME"
  if cleanup_workspace "$_CLEANUP_WS_PATH" "$_CLEANUP_SOURCES_DIR"; then
    log_succ "Workspace cleaned: $_CLEANUP_TASK_NAME"
  fi

  # Clear variables to prevent double cleanup
  _CLEANUP_WS_PATH=""
  _CLEANUP_SOURCES_DIR=""
  _CLEANUP_TASK_NAME=""
}

create_workspace() {
  local project_root="$1"
  local project_name="$2"
  local agent_task="$3"
  local base_branch="$4"
  local editor="${5:-zellij}"
  local target_branch_prefix="$6"

  local sources_dir="$project_root/sources"
  local target_ws="$project_root/workspaces/$agent_task"

  # Set global variables for cleanup trap
  _CLEANUP_WS_PATH="$target_ws"
  _CLEANUP_SOURCES_DIR="$sources_dir"
  _CLEANUP_TASK_NAME="$agent_task"

  # Set up signal trapping for robust cleanup
  trap 'do_cleanup' EXIT SIGINT SIGTERM SIGHUP

  if [[ -d "$target_ws" ]]; then
    log_warn "Resuming existing workspace: $agent_task"
  else
    log_info "Spawning Workspace: $agent_task (Base: $base_branch)"
    mkdir -p "$target_ws"

    # Create worktrees
    for repo in "$sources_dir"/*; do
      if [[ -d "$repo" && -d "$repo/.git" ]]; then
        local repo_name=$(basename "$repo")
        local branch_name=""

        if [[ -n "$target_branch_prefix" ]]; then
          branch_name="${target_branch_prefix}/${repo_name}"
        else
          branch_name="hap/${agent_task}/${repo_name}"
        fi

        git -C "$repo" worktree prune

        if ! git -C "$repo" worktree add "$target_ws/$repo_name" -b "$branch_name" "$base_branch" 2>/dev/null; then
          git -C "$repo" worktree add "$target_ws/$repo_name" "$branch_name"
        fi

        # Shared State Linking
        if [[ -d "$project_root/shared/$repo_name" ]]; then
          log_info "Linking shared state for $repo_name..."
          (
            cd "$project_root/shared/$repo_name" || exit
            find . -type f | while read -r file; do
              local clean_file="${file#./}"
              local dest_file="$target_ws/$repo_name/$clean_file"
              local dest_dir=$(dirname "$dest_file")

              mkdir -p "$dest_dir"

              local ups="../../../"
              local subdir=$(dirname "$clean_file")
              if [[ "$subdir" != "." ]]; then
                local sub_depth=$(echo "$subdir" | awk -F/ '{print NF}')
                for ((i = 0; i < sub_depth; i++)); do ups="../$ups"; done
              fi

              ln -sf "${ups}shared/$repo_name/$clean_file" "$dest_file"
            done
          )
        fi

        # Smart Install (Background)
        if [[ -f "$target_ws/$repo_name/pnpm-lock.yaml" ]]; then
          (cd "$target_ws/$repo_name" && pnpm install --frozen-lockfile --silent &)
        elif [[ -f "$target_ws/$repo_name/go.mod" ]]; then
          (cd "$target_ws/$repo_name" && go mod download &)
        fi
      fi
    done
    wait
    log_succ "Workspace ready"
  fi

  # Create PID lock file for zombie cleanup detection
  echo "$$" >"$target_ws/$PID_LOCK_FILE"

  # Launch session - blocking call for all editors
  local original_dir=$(pwd)
  cd "$target_ws" || exit 1
  launch_session "$project_name" "$target_ws" "$project_name-$agent_task" "lite" "$project_root" "$editor"
  cd "$original_dir" || true

  # Cleanup runs via trap or here when editor exits
  trap - EXIT SIGINT SIGTERM SIGHUP
  do_cleanup
}

# --- CLI ---

usage() {
  cat <<EOF
Usage: $APP_NAME [options]
  -s <name> [path]    Save project
  -w <name> <task>    Start workspace (Lite mode)
  -m <lite|full>      Force mode
  -e <editor>         Editor: zellij, cursor, antigravity (default: zellij)
  -b <branch>         Base branch for workspace (default: dev)
  -B <branch>         Target branch name (default: hap/<task>)
  -d <name>           Delete project
  -l                  List projects
  -v                  Show version
  (no args)           Open interactive selection
EOF
}

# --- MAIN ---

PROJECT_ARG=""
TASK_ARG=""
BRANCH_ARG="dev"
TARGET_BRANCH_ARG=""
MODE_ARG="default"
EDITOR_ARG="zellij"
ACTION="interactive"

while getopts "s:d:p:w:b:B:m:e:lhv" opt; do
  case $opt in
  s)
    ACTION="save"
    PROJECT_ARG="$OPTARG"
    eval "NEXT_OPT=\${$OPTIND}"
    if [[ -n "$NEXT_OPT" && "$NEXT_OPT" != -* ]]; then
      PROJECT_PATH="$NEXT_OPT"
      OPTIND=$((OPTIND + 1))
    else
      PROJECT_PATH="."
    fi
    ;;
  d)
    ACTION="delete"
    PROJECT_ARG="$OPTARG"
    ;;
  p)
    ACTION="open"
    PROJECT_ARG="$OPTARG"
    ;;
  b) BRANCH_ARG="$OPTARG" ;;
  B) TARGET_BRANCH_ARG="$OPTARG" ;;
  m) MODE_ARG="$OPTARG" ;;
  e) EDITOR_ARG="$OPTARG" ;;
  v)
    echo "hap v$VERSION"
    exit 0
    ;;
  w)
    ACTION="worktree"
    PROJECT_ARG="$OPTARG"
    eval "TASK_ARG=\${$OPTIND}"
    [[ -z "$TASK_ARG" || "$TASK_ARG" == -* ]] && {
      log_err "Missing task name"
      exit 1
    }
    OPTIND=$((OPTIND + 1))
    ;;
  l)
    column -t -s "|" "$DB_FILE"
    exit 0
    ;;
  h)
    usage
    exit 0
    ;;
  *)
    usage
    exit 1
    ;;
  esac
done

ensure_setup "$EDITOR_ARG"

case $ACTION in
save)
  [[ "$PROJECT_PATH" == "." ]] && FULL_PATH="$(pwd)" || FULL_PATH="$(cd "$PROJECT_PATH" && pwd)"
  echo "$PROJECT_ARG|$FULL_PATH" >>"$DB_FILE"
  log_succ "Saved $PROJECT_ARG"
  ;;
open)
  PATH_TO_ROOT=$(grep "^$PROJECT_ARG|" "$DB_FILE" | cut -d '|' -f 2 || true)
  if [[ -z "$PATH_TO_ROOT" ]]; then
    log_err "Project not found: $PROJECT_ARG"
    exit 1
  fi
  launch_session "$PROJECT_ARG" "$PATH_TO_ROOT/workspaces/main" "$PROJECT_ARG-main" "$MODE_ARG" "$PATH_TO_ROOT" "$EDITOR_ARG"
  ;;
worktree)
  PATH_TO_ROOT=$(grep "^$PROJECT_ARG|" "$DB_FILE" | cut -d '|' -f 2 || true)
  if [[ -z "$PATH_TO_ROOT" ]]; then
    log_err "Project not found: $PROJECT_ARG"
    exit 1
  fi
  create_workspace "$PATH_TO_ROOT" "$PROJECT_ARG" "$TASK_ARG" "$BRANCH_ARG" "$EDITOR_ARG" "$TARGET_BRANCH_ARG"
  ;;
interactive)
  if [[ ! -s "$DB_FILE" ]]; then
    log_warn "No projects found. Use 'hap -s <name> <path>' to save one."
    exit 0
  fi
  SELECTION=$(fzf --height=40% --layout=reverse --border --prompt="Select Hive > " --delimiter="|" --with-nth=1,2 <"$DB_FILE")
  if [[ -n "$SELECTION" ]]; then
    NAME=$(echo "$SELECTION" | cut -d '|' -f 1)
    PATH_TO_ROOT=$(echo "$SELECTION" | cut -d '|' -f 2)
    launch_session "$NAME" "$PATH_TO_ROOT/workspaces/main" "$NAME-main" "$MODE_ARG" "$PATH_TO_ROOT" "$EDITOR_ARG"
  fi
  ;;
esac
